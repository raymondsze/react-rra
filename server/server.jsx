import fs from 'fs';
import path from 'path';
import express from 'express';
import bodyParser from 'body-parser';
import loggerMiddleware from 'express-bunyan-logger';
import helmet from 'helmet';
import bunyan from 'bunyan';
import compression from 'compression';
import React from 'react';
import ReactDOMServer from 'react-dom/server';
import { graphqlExpress } from 'graphql-server-express';
// import graphql schema
import schema from '_server/schema';
// get the HTML Markup for the html response
import HTMLMarkup from '_server/components/HTMLMarkup';
// get the app information from package.json
import info from 'package.json';

// create the bunyan logger which log message as json format
const logger = bunyan.createLogger({
  name: `${info.name}@${info.version}`,
  serializers: bunyan.stdSerializers,
});

// setup the bunyan level
logger.level(process.env.LOG_LEVEL || bunyan.INFO);

const server = express();
// enable helmet
// ref: http://expressjs.com/zh-tw/advanced/best-practice-security.html
server.use(helmet());
// enable gzip
server.use(compression());
// enable json input in request body
server.use(bodyParser.json());
// this file would be generated by webpack build, with webpack-assets-plugn
const assetsFilePath = path.join(process.cwd(), 'build/client/webpack-assets.json');

// function to check if webpack build of client-side is finished
// the file should contain set of js and css requried to load
function clientBuilt(callback) {
  fs.access(assetsFilePath, fs.F_OK, (err) => {
    if (!err) {
      fs.readFile(assetsFilePath, { encoding: 'utf8' }, (error, data) => {
        callback(JSON.parse(data));
      });
    } else {
      setTimeout(() => clientBuilt(callback), 2000);
    }
  });
}

logger.info('Waiting client javascrpts built...');
clientBuilt((assets) => {
  let scripts = Object.values(assets).map(s => s.js);
  if (process.env.NODE_ENV === 'development') {
    scripts = ['/public/vendor_dll.js', ...scripts];
  }
  const styles = Object.values(assets).map(c => c.css);
  // map js to script tags
  const scriptTags = scripts.map(filepath =>
    (<script key={filepath} type="text/javascript" src={filepath} charSet="utf-8" />),
  );
  // map css to style tags
  const styleTags = styles.map(filepath =>
    (<link key={filepath} rel="stylesheet" type="text/css" href={filepath} charSet="utf-8" />),
  );

  // health check
  server.get('/health', (req, res) => res.status(200).end());
  // trust front facing proxy, this express server is behind proxy
  // it will look for the X-Forwared-For header instead of the ipaddress
  server.enable('trust proxy');

  // bunyan logger middleware
  server.use(loggerMiddleware());
  server.use(loggerMiddleware.errorLogger());

  server.use('/sw.js', (req, res) => {
    res.sendFile(path.resolve(process.cwd(), 'build/client/sw.js'));
  });

  // in case we need to handle https in application server
  if (process.env.NODE_ENV !== 'development' && process.env.HTTPS === 'true') {
    server.use((req, res, next) => {
      let ip = req.ip ||
        req.connection.remoteAddress ||
        req.socket.remoteAddress ||
        req.connection.socket.remoteAddress;
      // to obtain the correct ip address, ::ffff: is quirk of ipv6 for ipv4
      if (ip.substr(0, 7) === '::ffff:') {
        ip = ip.substr(7);
      }
      if (ip !== '127.0.0.1') {
        if ((!req.secure) && (req.get('X-Forwarded-Proto') !== 'https')) {
          res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
          return res.redirect(`https://${req.get('Host')}${req.url}`);
        }
      }
      return next();
    });
  }

  // graphql
  server.use('/graphql',
    // TODO: add login endpoint via passport
    // passport.authenticate('jwt', { session: false }),
    (req, res, next) => graphqlExpress({
      schema,
      formatError(error) {
        return error;
      },
    })(req, res, next));

  // assets, set maxAge for caching
  server.use('/public', express.static(path.join(process.cwd(), 'build/client'), { maxAge: '30d' }));

  // view
  server.get('*', (req, res) => {
    (async () => {
      // if support server side rendering
      if (process.env.SSR === 'true') {
        // get all the dependency
        const { default: Helmet } = await import('react-helmet');
        const { AsyncComponentProvider, createAsyncContext } = await import('react-async-component');
        const { default: asyncBootstrapper } = await import('react-async-bootstrapper');
        const { AppContainer } = await import('react-hot-loader');
        const { ConnectedRouter } = await import('react-router-redux');
        const { default: createMemoryHistory } = await import('history/createMemoryHistory');
        const { styleSheet } = await import('styled-components');
        const { END } = await import('redux-saga');
        const { ApolloProvider, getDataFromTree } = await import('react-apollo');
        const { default: createApolloClient } = await import('_client/redux/apolloClient');
        const { default: configureStore } = await import('_client/redux/store');
        const { default: App } = await import('_client/containers/App');
        // const { createNetworkInterface } = await import('apollo-client');
        const serialize = await import('serialize-javascript');
        const { createLocalInterface } = await import('apollo-local-query');
        const { execute } = await import('graphql');
        const networkInterface = createLocalInterface({ execute }, schema);
        // styleSheet.reset();
        // create apollo graphql client
        const apolloClient = createApolloClient({
          networkInterface,
          ssrMode: true,
          connectToDevTools: false,
        });
        // server side only contain memeory history
        const memoryHistory = createMemoryHistory(req.url);
        // configure store
        const store = configureStore({
          apolloClient,
          history: memoryHistory,
        });
        const router = (
          <ConnectedRouter history={memoryHistory}>
            <App />
          </ConnectedRouter>
        );
        const asyncContext = createAsyncContext();
        const apolloProvider = (
          <AsyncComponentProvider asyncContext={asyncContext}>
            <ApolloProvider client={apolloClient} store={store}>
              {router}
            </ApolloProvider>
          </AsyncComponentProvider>
        );
        await asyncBootstrapper(apolloProvider);
        await getDataFromTree(apolloProvider);
        const asyncState = asyncContext.getState();
        await store.dispatch(END);
        await Promise.all(store.asyncTasks.map(task => task.done));
        /* eslint-enable react/no-danger */
        // allow using Helmet to inject html header
        const head = Helmet.rewind();
        const htmlAttributes = head ? head.htmlAttributes.toComponent() : null;
        const metas = head ? [
          head.base.toComponent(),
          head.title.toComponent(),
          head.meta.toComponent(),
          head.link.toComponent(),
        ] : null;
        const content = ReactDOMServer.renderToString(
          <AppContainer>
            {apolloProvider}
          </AppContainer>,
        );
        // get the latest state
        const initialState = apolloClient.store.getState();
        /* eslint-disable react/no-danger */
        const inlineStyles = [
          <style
            key="styled-components"
            dangerouslySetInnerHTML={{
              __html: styleSheet.getCSS(),
            }}
          />,
        ];
        const inlineScripts = [
          <script
            key="redux"
            dangerouslySetInnerHTML={{
              __html: `window.__REDUX_STATE__ = ${serialize(initialState)}`,
            }}
          />,
          <script
            key="async-components"
            dangerouslySetInnerHTML={{
              __html: `window.__ASYNC_COMPONENTS_STATE__ = ${serialize(asyncState)}`,
            }}
          />,
        ];
        // generate markup
        /* eslint-disable react/no-danger */
        const markup = (
          <HTMLMarkup
            htmlAttributes={htmlAttributes}
            metas={metas}
            styles={styleTags}
            scripts={[
              ...scriptTags,
              head.script.toComponent(),
            ]}
            inlineStyles={inlineStyles}
            inlineScripts={inlineScripts}
            content={content}
          />
        );
        /* eslint-enable react/no-danger */
        res.status(200)
          .set({ 'content-type': 'text/html' })
          .send(ReactDOMServer.renderToStaticMarkup(markup));
      } else {
        res.status(200)
          .set({ 'content-type': 'text/html' })
          .send(ReactDOMServer.renderToStaticMarkup(
            <HTMLMarkup styles={styleTags} scripts={scriptTags} />));
      }
    })().catch((e) => {
      logger.error(e);
      res.status(500).send(e.message);
    });
  });

  server.listen(process.env.PORT, (error) => {
    // do not use console.log or console.error, but use the bunyan logger
    if (error) logger.error(`Web Server is failed to start at http://${process.env.HOSTNAME}:${process.env.PORT}.`, error);
    else logger.info(`Web Server is started at http://${process.env.HOSTNAME}:${process.env.PORT}.`);
  });

  process.on('uncaughtException', (err) => {
    // if get uncaughtException, log the error with bunyan as well
    logger.error(err);
    process.exit(1);
  });
});
